https://www.youtube.com/watch?v=okoySbtai_Y

Dependabot, Renovate & Co

Привет! Вчера мы рассмотрели GitHub Actions, защиту филиалов и другие подобные темы. И мы пришли к выводу, что это действительно хороший рабочий процесс. Но как мы справляемся с зависимостями? Как мне узнать, что есть обновление? Как мне их включить?
И я бы хотел, чтобы все это было максимально автоматизировано, потому что это утомительно, когда приходится постоянно возиться с барабанами вручную.
Прежде всего, очень важный момент, чтобы все это работало – это работать со строго закрепленными версиями.
Мы уже говорили об этом в Developer’s Daily № 12. Это важно. Это должно регулироваться файлом журнала, но пока это работает в npm updated хорошо.
Вы определенно хотите иметь предсказуемые установки. И поэтому вам нужно подумать, как это сделать. И поэтому закрепленные версии – хорошая идея.
Недостаток строго закрепленных версий в том, что ты зацикливаешься ровно на одной версии. Это как раз то преимущество оператора диапазона, что вы автоматически выпускаешь исправление ошибок. Вы получаете второстепенные выпуски. И именно с ними вы играете.
Возникает вопрос – что с этим делать?
Первый вариант, чтобы вы регулярно запускали npm updated. Эта команда действительно похожа на package Jason или содержимое package.
Jason с установленными конкретными модулями будет начинаться с содержимого npm registry. Т. е. вы получите уведомление, когда появятся новые версии, потому что вы получите соответствующее сообщение.
Но загвоздка в том, что кто-то должен выполнять эту команду на регулярной основе. Мы делали это раньше. И это было частью нашего тестового запуска. В каком-то смысле это тоже было хорошо.
Это хорошо работает, когда над кодом все равно регулярно работают. Но если долгое время никто ничего не 
делал с модулем, то это потому, что тесты больше не выполняются регулярно. Тогда npm updated больше не будет работать регулярно.
Это означает, что это хорошее решение, но не отличное. Поэтому нужно было сделать это автоматизированным способом, чтобы выполнялось регулярно.
И здесь появляется инструмент, который называется Dependabot. Он и раньше был самостоятельным инструментом. Теперь принадлежит GitHub.
Есть альтернатива Dependabot’у. Например, Renovate, который тоже прекрасно сочетается с GitLab.
Вам придется установить его вручную, потом что это именно то, что нужно для самостоятельного хостинга. Но тогда у вас будет возможность использовать его и на других платформах, кроме учетной записи GitHub, размещенной в облаке.
Кроме Dependabot и Renovate есть еще несколько инструментов. И все они работают одинаково.
Ниже я расскажу, как мы справляемся с этим с помощью Dependabot.
Здесь тоже есть конфигурационный файл, который находится в каталоге. Зависимый. И это файл yaml. В данном 
случае файл с именем config.yaml. В этом файле я должен сначала указать, где находится package jacksons, который должен контролироваться. Он часто находится в главном каталоге модуля, но это не обязательно должно быть так. Если у вас есть несколько моно-репозиторий может быть несколько package Jackson. Тогда я могу соответствующим образом настроить, где находятся эти несколько файлов.
Я могу указать, как часто я хочу просматривать эти файлы: будь то ежедневно, еженедельно, ежемесячно или даже в режиме реального времени и какие обновления меня интересуют. Т. е. хочу ли я получать каждое обновление, хочу ли я получать только прямые или косвенные обновления, хочу ли я просто иметь обновления безопасности и т. д. И это можно сделать как в Dependabot, так и в Renovate.
Это означает, что вы также можете с помощью Dependabot и Renovate убедиться, что базовый образ остается актуальным. И если Dependabot станет активным, то в конечном итоге произойдет то, что … будет запущен устаревшим. Но вы не только получите уведомление, если какая-то зависимость устарела, если есть более новая версия, но и автоматически выполнится запрос на перенос. Это означает, что вы не только получаете уведомление, но и получаете обновление напрямую.
Теперь все возвращается на круги своя. Если у вас есть автоматизированные тесты, если у вас автоматизированный анализ кода и это выполняется для запросов на выборку, то, конечно, то же самое выполняется и для на выборку Dependabot. Это означает, что вы сразу видите – будет ли обновляться зависимость или нет. И тогда вы можете быть относительно спокойны по этому поводу.
Теперь во всей этой истории есть одна проблема, а именно, что обычно вы получаете несколько запросов на перенос, когда есть несколько зависимостей, от которых есть новая версия.
Как только вы объединяете один, все остальные запросы на перенос устаревают, потому что основная ветвь находится на один commit дальше. И мы уже говорили об этом вчера, что ветви должны быть обновлены.
Если вы на самом деле хотите заставить это работать, то это означает, что в результате вы должны перебазировать эти функциональные ветки или просто объединить основную ветку в соответствующую функциональную ветку.
Бот, т. е. бот Dependabot или Renovate тоже может это сделать, но вы также можете управлять этим вручную. И вы также можете дать команду боту, например, чтобы он закрыл PR и не открывал его снова, потому что эта версия вас не интересует, потому что вы, как правило, хотите игнорировать полную основную версию этой зависимости.
Очень интересная особенность в Renovate, чего мне до сих пор не хватает в Dependabot – это то, что вы можете выполнять обновления для нескольких зависимостей, что вы можете сгруппировать это в один запрос на  перенос, что вы можете сделать, например, один запрос на перенос для зависимостей и один для depend… .
Суть в том, что это требует гораздо меньше усилий, быстрее и удобнее, но данный момент, как я говорил, это предлагает только Renovate.
И здесь есть недостаток по сравнению с Dependabot. Вы должны размещать его самостоятельно. И вам нужно позаботиться о том, чтобы просто регулярно запускать его практически … .
Dependabot более интегрирован по сравнению с ним. Но, как я уже сказал, в конечном итоге это не имеет значения.
Оба инструмента ведут к одной цели. И неважно используете ли вы один или другой, а то, что вы используете один и тот же инструмент, а потом вам удается автоматически получать новые версии и вы автоматизировали управление зависимостями. И это совершенно независимо активно ли вы работаете над кодом в данный момент или нет. С этим мы справились. Мы получили новые версии.
Но чего еще не хватает, так это того, что мы сами создаем новые версии в автоматическом режиме. И для этого тоже есть подходы. Тогда это семантическое управление версиями и семантический выпуск. И как это работает, мы посмотрим завтра. 